"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _mimeTypes = require("mime-types");

var _path = require("path");

var _quaff = _interopRequireDefault(require("quaff"));

var _streamToString = _interopRequireDefault(require("stream-to-string"));

var _yamlJs = _interopRequireDefault(require("yaml-js"));

var _util = require("util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  createReadStream
} = _fs.default;
const stat = (0, _util.promisify)(_fs.default.stat);
const parsers = {
  'text/yaml': string => _yamlJs.default.load(string),
  'application/json': string => JSON.parse(string)
};

var _default = async ({
  path,
  mime: inputMime
}) => {
  let input;
  let mime;

  if ('-' === path) {
    mime = inputMime || (0, _mimeTypes.lookup)('.json');
    input = process.stdin;
  } else if (path && (await stat(path)).isDirectory()) {
    return (0, _quaff.default)(path);
  }

  if (!input) {
    mime = inputMime || (0, _mimeTypes.lookup)(path);
    input = createReadStream((0, _path.resolve)(process.cwd(), path));
  }

  if (!input) {
    throw new Error('resume could not be gotten from path or stdin');
  }

  const resumeString = await (0, _streamToString.default)(input);
  const parser = parsers[mime];

  if (!parser) {
    throw new Error(`no parser available for detected mime type ${mime}`);
  }

  return parser(resumeString);
};

exports.default = _default;